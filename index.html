<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: data: blob: 'unsafe-inline' 'unsafe-eval'; connect-src 'self' https:; script-src 'self' https: 'unsafe-inline' 'unsafe-eval'; style-src 'self' https: 'unsafe-inline';">
    <title>Ball Dodge Arena (Combat)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@700&display=swap');
        body { background-color: #0d1117; font-family: 'Chakra Petch', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; overflow: hidden; }
        #game-container { position: relative; box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5), 0 0 50px rgba(0, 255, 255, 0.2); border: 4px solid #00ffff; border-radius: 12px; background-color: #161b22; }
        canvas { display: block; touch-action: none; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px); border-radius: 8px; z-index: 10; pointer-events: none; }
        .game-over-visible { pointer-events: auto !important; }
        .game-button { transition: all 0.2s ease-in-out; box-shadow: 0 0 15px #00ffff; background: linear-gradient(145deg, #00bfff, #00ffff); color: #0d1117; text-transform: uppercase; letter-spacing: 2px; font-size: 1.25rem; padding: 0.75rem 2rem; font-weight: 700; }
        .game-button:hover { transform: scale(1.05); box-shadow: 0 0 25px #00ffff, 0 0 50px #00ffff; }
        #shopContainer { background-color: #161b22; border: 2px solid #39ff14; border-radius: 10px; max-width: 95%; width: 600px; max-height: 90%; display: grid; grid-template-rows: auto 1fr auto; gap: 1.5rem; padding: 2rem; }
        #shipList { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1.5rem; padding: 0.5rem; overflow-y: auto; max-height: 450px; }
        .ship-card { background-color: #1f2733; border: 1px solid #334d60; border-radius: 10px; padding: 1rem; display: flex; flex-direction: column; align-items: center; transition: all 0.3s; }
        .ship-card[data-glow-color="#ff0000"] { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
        .ship-card[data-glow-color="#ee82ee"] { box-shadow: 0 0 10px rgba(238, 130, 238, 0.5); }
        .ship-card[data-glow-color="#ffff00"] { box-shadow: 0 0 10px rgba(255, 255, 0, 0.5); }
        .ship-card[data-glow-color="#00bfff"] { box-shadow: 0 0 10px rgba(0, 191, 255, 0.5); }
        .ship-card[data-glow-color="#39ff14"] { box-shadow: 0 0 15px rgba(57, 255, 20, 0.8); }
        .ship-card.equipped { border: 3px solid #39ff14; transform: scale(1.05); box-shadow: 0 0 20px #39ff14; }
        .ship-card:not(.equipped):hover { transform: translateY(-8px); border-color: #00ffff; }
    </style>
</head>
<body>
    <div id="game-container" class="w-full max-w-lg mx-auto aspect-square">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
        <div id="scoreDisplay" class="absolute top-4 left-4 text-2xl font-bold text-cyan-400">TIME: 0.00s</div>
        <div id="coinDisplay" class="absolute top-4 right-4 text-2xl font-bold text-yellow-400">COINS: 0</div>
        <div id="overlay">
            <div id="standardOverlay" class="flex flex-col justify-center items-center">
                <h1 id="overlayTitle" class="text-6xl mb-4 font-extrabold tracking-widest text-cyan-400"></h1>
                <p id="overlayMessage" class="text-4xl text-white mb-4 text-center"></p>
                <p id="totalCoinsMessage" class="text-3xl text-yellow-400 mb-8 text-center"></p>
                <button id="actionButton" class="game-button rounded-full"></button>
                <button id="shopButton" class="game-button rounded-full mt-4 bg-purple-600" style="box-shadow: 0 0 15px #ee82ee;">VISIT THE SHOP</button>
                <p class="text-sm text-gray-400 mt-6">(WASD / Arrows / Tap to move & shoot)</p>
            </div>
            <div id="shopContainer" class="hidden w-full h-full p-4">
                <h2 class="text-4xl font-extrabold text-white mb-4 text-center pb-2 text-cyan-300">SHIP MARKETPLACE</h2>
                <div id="shipList" class="grid" style="max-height: 450px;"></div>
                <div class="mt-4 flex flex-col sm:flex-row justify-between items-center border-t pt-4 border-cyan-500">
                    <p class="text-2xl text-yellow-400 font-bold mb-4 sm:mb-0">Balance: <span id="shopCoinBalance">0</span> COINS</p>
                    <button id="backButton" class="game-button rounded-full px-4 py-2" style="font-size: 1rem;">BACK TO ARENA</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // OFFLINE MODE â€” NO FREEZE, NO FIREBASE WAIT
        const isAuthReady = true;
        const userId = "local-user";
        let coins = 0, sessionCoins = 0, equippedShipId = 'default', ownedShipIds = ['default'];
        let lastCoinUpdateTime = 0;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const coinDisplay = document.getElementById('coinDisplay');
        const totalCoinsMessage = document.getElementById('totalCoinsMessage');
        const overlay = document.getElementById('overlay');
        const standardOverlay = document.getElementById('standardOverlay');
        const shopContainer = document.getElementById('shopContainer');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMessage = document.getElementById('overlayMessage');
        const actionButton = document.getElementById('actionButton');
        const shopButton = document.getElementById('shopButton');
        const backButton = document.getElementById('backButton');
        const shipList = document.getElementById('shipList');
        const shopCoinBalance = document.getElementById('shopCoinBalance');

        const PLAYER_SIZE = 25;
        const METEOR_GLOW_COLOR = '#ff4500';
        const METEOR_BODY_COLOR = '#4a4a4a';
        const HIT_SOUND_COOLDOWN = 50;
        const ROTATION_SPEED = 0.15;
        const MAX_ROTATION = Math.PI / 8;

        const SHIP_DATA = [
            { id: 'default', name: 'Standard Vanguard', multiplier: 1, price: 0, rarity: 'Standard', color: '#40e0d0', glow: '#00ffff', engineColor: '#ff6600', particleType: 0, damage: 1 },
            { id: 'viper', name: 'Crimson Viper', multiplier: 2, price: 30, rarity: 'Uncommon', color: '#8b0000', glow: '#ff0000', engineColor: '#ff4500', particleType: 1, damage: 2 },
            { id: 'ghost', name: 'Phantom Cloak', multiplier: 3, price: 100, rarity: 'Rare', color: '#9400d3', glow: '#ee82ee', engineColor: '#9400d3', particleType: 2, damage: 5 },
            { id: 'titan', name: 'Aether Titan', multiplier: 4, price: 250, rarity: 'Epic', color: '#daa520', glow: '#ffff00', engineColor: '#daa520', particleType: 1, damage: 10 },
            { id: 'quantum', name: 'Quantum Core', multiplier: 5, price: 500, rarity: 'Legendary', color: '#ffffff', glow: '#00bfff', engineColor: '#00ffff', particleType: 3, damage: 20 },
            { id: 'ultimate', name: 'Nebula Sovereign', multiplier: 6, price: 1000, rarity: 'Mythic', color: '#39ff14', glow: '#39ff14', engineColor: '#39ff14', particleType: 2, damage: 40 }
        ];

        let gameRunning = false;
        let player = { x: 0, y: 0, dx: 0, dy: 0, speed: 5, rotation: 0, particles: [] }; 
        let balls = [], projectiles = [], score = 0, lastTime = 0, spawnTimer = 0, ballSpeedFactor = 1.0, spawnInterval = 1000;
        let lastHitSoundTime = 0, keys = {};
        let isToneInitialized = false;
        let noiseSynth = null, laserSynth = null, hitSynth = null;
        let audioUnlocked = false;

        // FIXED: Initialize Tone.js only after first user click, with proper error handling
        async function initializeTone() {
            if (isToneInitialized) return;
            try {
                await Tone.start();
                console.log("Tone.js started successfully");
                isToneInitialized = true;
                createSynths();
                audioUnlocked = true;
            } catch (e) {
                console.warn("Tone.js failed to start:", e);
                isToneInitialized = true;
                audioUnlocked = false;
            }
        }

        function createSynths() {
            if (!noiseSynth) noiseSynth = new Tone.NoiseSynth({ 
                noise: { type: 'white' }, 
                envelope: { attack: 0.001, decay: 0.15, sustain: 0.01, release: 0.15 } 
            }).toDestination();
            if (!laserSynth) laserSynth = new Tone.Synth({ 
                oscillator: { type: "square" }, 
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 }, 
                volume: -15 
            }).toDestination();
            if (!hitSynth) hitSynth = new Tone.MembraneSynth({ 
                volume: -18, pitchDecay: 0.01, octaves: 2, 
                envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.05 } 
            }).toDestination();
        }

        function disposeSynths() {
            if (noiseSynth) { noiseSynth.dispose(); noiseSynth = null; }
            if (laserSynth) { laserSynth.dispose(); laserSynth = null; }
            if (hitSynth) { hitSynth.dispose(); hitSynth = null; }
        }

        function playGameOverSound() { 
            if (audioUnlocked && noiseSynth) {
                noiseSynth.triggerAttackRelease("2n");
            }
        }
        function playLaserSound() { 
            if (audioUnlocked && laserSynth) {
                laserSynth.triggerAttackRelease("C6", "16n");
            }
        }
        function playHitSound() { 
            const currentTime = performance.now();
            if (currentTime - lastHitSoundTime < HIT_SOUND_COOLDOWN) return;
            if (audioUnlocked && hitSynth) {
                hitSynth.triggerAttackRelease("C3", "32n");
            }
            lastHitSoundTime = currentTime;
        }

        function updateCoinDisplay() {
            coinDisplay.textContent = `COINS: ${coins + sessionCoins}`;
            if (shopCoinBalance) shopCoinBalance.textContent = coins;
        }

        window.attemptPurchase = attemptPurchase;
        window.equipShip = equipShip;

        function showShop() {
            standardOverlay.style.display = 'none';
            shopContainer.style.display = 'grid';
            overlay.style.display = 'flex';
            overlay.classList.add('game-over-visible');
            renderShop();
            updateCoinDisplay();
        }

        function renderShop() {
            shipList.innerHTML = '';
            SHIP_DATA.forEach(ship => {
                const isOwned = ownedShipIds.includes(ship.id);
                const isEquipped = equippedShipId === ship.id;
                let buttonText = 'EQUIP';
                let buttonClasses = 'px-3 py-1 text-sm rounded-full font-bold transition-all';
                let action = `equipShip('${ship.id}')`;
                
                if (!isOwned) {
                    buttonText = `BUY - ${ship.price} COINS`;
                    buttonClasses += ' bg-yellow-500 hover:bg-yellow-400 text-gray-900 shadow-lg shadow-yellow-700/50';
                    action = `attemptPurchase('${ship.id}', ${ship.price})`;
                } else if (isEquipped) {
                    buttonText = 'EQUIPPED';
                    buttonClasses += ' bg-green-500 opacity-80 cursor-default text-gray-900 shadow-lg shadow-green-700/50';
                    action = '';
                } else {
                    buttonClasses += ' bg-cyan-500 hover:bg-cyan-400 text-gray-900 shadow-lg shadow-cyan-700/50';
                }

                let rarityColor = 'text-gray-400';
                if (ship.rarity === 'Uncommon') rarityColor = 'text-green-400';
                else if (ship.rarity === 'Rare') rarityColor = 'text-blue-400';
                else if (ship.rarity === 'Epic') rarityColor = 'text-purple-400';
                else if (ship.rarity === 'Legendary') rarityColor = 'text-yellow-400';
                else if (ship.rarity === 'Mythic') rarityColor = 'text-pink-400';

                const card = document.createElement('div');
                card.className = `ship-card ${isEquipped ? 'equipped' : ''}`;
                card.setAttribute('data-glow-color', ship.glow);
                card.innerHTML = `
                    <h3 class="text-2xl font-bold ${rarityColor} mb-1">${ship.name}</h3>
                    <p class="text-sm ${rarityColor} italic mb-2">(${ship.rarity})</p>
                    <div class="w-20 h-20 rounded-full flex items-center justify-center mb-4 border-2 border-white/20" 
                         style="background-color: ${ship.color}; box-shadow: 0 0 20px ${ship.glow}, inset 0 0 8px white;">
                        <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: ${ship.engineColor};">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                        </svg>
                    </div>
                    <p class="text-white text-lg font-mono mb-1">Multiplier: <span class="text-cyan-400">${ship.multiplier}x</span></p>
                    <p class="text-white text-lg font-mono mb-4">Damage: <span class="text-red-400">${ship.damage}</span></p>
                    <button onclick="${action}" class="${buttonClasses}" ${isEquipped ? 'disabled' : ''}>${buttonText}</button>
                    <p id="msg-${ship.id}" class="text-xs text-red-400 mt-2 h-4"></p>
                `;
                shipList.appendChild(card);
            });
        }

        function attemptPurchase(shipId, price) {
            if (coins >= price) {
                coins -= price;
                ownedShipIds.push(shipId);
                equipShip(shipId);
                const msgEl = document.getElementById(`msg-${ship.id}`);
                if (msgEl) {
                    msgEl.textContent = 'Purchased & Equipped!';
                    msgEl.classList.remove('text-red-400'); msgEl.classList.add('text-green-400');
                    setTimeout(() => msgEl.textContent = '', 2000);
                }
            } else {
                const msgEl = document.getElementById(`msg-${ship.id}`);
                if (msgEl) {
                    msgEl.textContent = 'Not enough coins!';
                    msgEl.classList.add('text-red-400'); msgEl.classList.remove('text-green-400');
                    setTimeout(() => msgEl.textContent = '', 2000);
                }
            }
            renderShop();
            updateCoinDisplay();
        }

        function equipShip(shipId) {
            if (ownedShipIds.includes(shipId)) {
                equippedShipId = shipId;
                renderShop();
                const msgEl = document.getElementById(`msg-${ship.id}`);
                if (msgEl) {
                    msgEl.textContent = 'Equipped!';
                    msgEl.classList.remove('text-red-400'); msgEl.classList.add('text-green-400');
                    setTimeout(() => msgEl.textContent = '', 2000);
                }
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const size = Math.min(container.offsetWidth, container.offsetHeight);
            canvas.width = size;
            canvas.height = size;
        }

        // FIXED: Ensure Tone.js is initialized before starting game
        async function startGame() {
            await initializeTone();
            resizeCanvas();
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.dx = 0; player.dy = 0; player.rotation = 0; player.particles = [];
            balls = []; projectiles = []; score = 0; sessionCoins = 0;
            lastTime = performance.now(); lastCoinUpdateTime = lastTime; lastHitSoundTime = 0;
            spawnTimer = spawnInterval; ballSpeedFactor = 1.0; keys = {};
            overlay.classList.remove('game-over-visible'); overlay.style.display = 'none'; 
            gameRunning = true;
            updateCoinDisplay(); draw(); requestAnimationFrame(gameLoop);
        }

        function initStartScreen() {
            resizeCanvas(); draw();
            updateCoinDisplay();
            shopContainer.style.display = 'none'; standardOverlay.style.display = 'flex';
            overlayTitle.textContent = 'BALL DODGE ARENA';
            overlayTitle.classList.remove('text-red-500', 'animate-pulse'); overlayTitle.classList.add('text-cyan-400');
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            const multiplier = currentShip ? currentShip.multiplier : 1;
            const damage = currentShip ? currentShip.damage : 1;
            overlayMessage.textContent = `Equipped: ${currentShip.name} (${multiplier}x Multiplier, ${damage} Damage).`;
            totalCoinsMessage.textContent = ''; actionButton.textContent = 'START ARENA';
            overlay.style.display = 'flex'; overlay.classList.add('game-over-visible');
        }

        function spawnBall() {
            const minBallSize = 15;
            const maxBallSize = 25;
            const size = Math.floor(Math.random() * (maxBallSize - minBallSize + 1)) + minBallSize;
            const radius = size / 2;
            const health = Math.max(1, Math.floor(radius * 1.5));
            const newBall = {
                x: Math.random() * (canvas.width - size * 2) + size, 
                y: -size, 
                radius: radius,
                speed: (3 + Math.random() * 3) * ballSpeedFactor, 
                health: health,
                maxHealth: health,
            };
            balls.push(newBall);
        }

        function shootProjectile() {
            if (!gameRunning) return;
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            if (!currentShip) return;
            playLaserSound();
            projectiles.push({
                x: player.x,
                y: player.y - PLAYER_SIZE,
                radius: 3,
                speed: 15,
                damage: currentShip.damage,
                color: currentShip.glow,
                vx: 0,
                vy: -1,
            });
        }

        function updateParticles(deltaTime) {
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            if (!currentShip || currentShip.particleType === 0) {
                player.particles = [];
                return;
            }
            if (Math.random() < 0.8) {
                const angle = player.rotation;
                const baseLength = PLAYER_SIZE * 0.7;
                const offset = { x: baseLength * Math.sin(angle), y: baseLength * Math.cos(angle) };
                player.particles.push({
                    x: player.x - offset.x + (Math.random() - 0.5) * 8,
                    y: player.y + offset.y + (Math.random() - 0.5) * 8,
                    vx: -(Math.sin(angle) * 0.5 + (Math.random() - 0.5) * 0.5),
                    vy: (Math.cos(angle) * 0.5 + (Math.random() * 2)),
                    life: 100,
                    size: currentShip.particleType === 3 ? 2.5 : 1.5,
                    color: currentShip.engineColor
                });
            }
            for (let i = player.particles.length - 1; i >= 0; i--) {
                const p = player.particles[i];
                p.x += p.vx * deltaTime / 16.67;
                p.y += p.vy * deltaTime / 16.67;
                p.life -= 1;
                p.vy *= 0.98;
                if (p.life <= 0) player.particles.splice(i, 1);
            }
        }

        function update(currentTime) {
            if (!gameRunning) return;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            const deltaSeconds = deltaTime / 1000;

            score += deltaSeconds;
            scoreDisplay.textContent = `TIME: ${score.toFixed(2)}s`;

            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            const multiplier = currentShip ? currentShip.multiplier : 1;
            if (currentTime - lastCoinUpdateTime >= 1000) {
                const secondsPassed = Math.floor((currentTime - lastCoinUpdateTime) / 1000);
                sessionCoins += multiplier * secondsPassed;
                lastCoinUpdateTime += secondsPassed * 1000;
                updateCoinDisplay();
            }

            let moveX = 0, moveY = 0;
            if (keys['w'] || keys['W'] || keys['ArrowUp']) moveY = -1;
            else if (keys['s'] || keys['S'] || keys['ArrowDown']) moveY = 1;
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) moveX = -1;
            else if (keys['d'] || keys['D'] || keys['ArrowRight']) moveX = 1;
            if (moveX !== 0 && moveY !== 0) {
                const mag = Math.sqrt(moveX*moveX + moveY*moveY);
                moveX /= mag; moveY /= mag;
            }
            player.x += moveX * player.speed;
            player.y += moveY * player.speed;

            let targetRotation = 0;
            if (moveX < 0) targetRotation = -MAX_ROTATION;
            else if (moveX > 0) targetRotation = MAX_ROTATION;
            player.rotation += (targetRotation - player.rotation) * ROTATION_SPEED;

            const halfSize = PLAYER_SIZE / 2;
            player.x = Math.max(halfSize, Math.min(canvas.width - halfSize, player.x));
            player.y = Math.max(halfSize, Math.min(canvas.height - halfSize, player.y));

            updateParticles(deltaTime);

            spawnTimer -= deltaTime;
            if (spawnTimer <= 0) {
                spawnBall();
                ballSpeedFactor = 1.0 + Math.min(score / 50, 4.0);
                spawnInterval = Math.max(1000 - score * 10, 50);
                spawnTimer = spawnInterval;
            }

            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                ball.y += ball.speed * (deltaTime / 16.67);
                if (ball.y - ball.radius > canvas.height) balls.splice(i, 1);
                if (checkCollision(player, ball)) { gameOver(); return; }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.y += p.vy * p.speed * (deltaTime / 16.67);
                if (p.y + p.radius < 0) { projectiles.splice(i, 1); continue; }
                let hit = false;
                for (let j = balls.length - 1; j >= 0; j--) {
                    const ball = balls[j];
                    const dx = p.x - ball.x;
                    const dy = p.y - ball.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < (p.radius + ball.radius)) {
                        hit = true;
                        ball.health -= p.damage;
                        playHitSound();
                        if (ball.health <= 0) {
                            const reward = Math.ceil(ball.maxHealth / 2);
                            sessionCoins += reward;
                            updateCoinDisplay();
                            balls.splice(j, 1);
                        }
                        break;
                    }
                }
                if (hit) projectiles.splice(i, 1);
            }
        }

        function checkCollision(p, b) {
            const dx = p.x - b.x;
            const dy = p.y - b.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (b.radius + PLAYER_SIZE / 2); 
        }

        function drawPlayer() {
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId) || SHIP_DATA[0];
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.rotation); 
            const halfSize = PLAYER_SIZE / 2;

            player.particles.forEach(p => {
                ctx.globalAlpha = p.life / 100;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x - player.x, p.y - player.y, p.size * (p.life/100), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });

            ctx.shadowColor = currentShip.engineColor;
            ctx.shadowBlur = 10;
            ctx.fillStyle = currentShip.engineColor; 
            ctx.fillRect(-halfSize * 0.6, halfSize, halfSize * 1.2, PLAYER_SIZE * 0.5); 

            ctx.shadowColor = currentShip.glow;
            ctx.shadowBlur = 15;
            ctx.fillStyle = currentShip.color;
            ctx.beginPath();
            if (currentShip.id === 'default' || currentShip.id === 'viper') {
                ctx.moveTo(0, -PLAYER_SIZE);
                ctx.lineTo(halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 1.5, halfSize);
            } else if (currentShip.id === 'ghost') {
                ctx.moveTo(0, -PLAYER_SIZE);
                ctx.lineTo(halfSize * 1.5, halfSize * 0.5);
                ctx.lineTo(halfSize * 0.8, halfSize);
                ctx.lineTo(-halfSize * 0.8, halfSize);
                ctx.lineTo(-halfSize * 1.5, halfSize * 0.5);
            } else if (currentShip.id === 'titan') {
                ctx.moveTo(0, -PLAYER_SIZE);
                ctx.lineTo(halfSize * 2, halfSize * 0.8);
                ctx.lineTo(halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 2, halfSize * 0.8);
            } else if (currentShip.id === 'quantum' || currentShip.id === 'ultimate') {
                ctx.moveTo(0, -PLAYER_SIZE * 1.2);
                ctx.lineTo(halfSize * 0.5, -halfSize * 0.5);
                ctx.lineTo(halfSize * 2, halfSize * 0.8);
                ctx.lineTo(halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 2, halfSize * 0.8);
                ctx.lineTo(-halfSize * 0.5, -halfSize * 0.5);
            }
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.fillStyle = '#0d1117';
            ctx.beginPath();
            ctx.arc(0, -PLAYER_SIZE * 0.4, PLAYER_SIZE * 0.2, 0, Math.PI * 2);
            ctx.fill();

            if (currentShip.id === 'ghost' || currentShip.id === 'titan' || currentShip.id === 'quantum' || currentShip.id === 'ultimate') {
                ctx.fillStyle = currentShip.engineColor;
                ctx.shadowColor = currentShip.engineColor;
                ctx.shadowBlur = 5;
                if (currentShip.id === 'ghost') {
                    ctx.fillRect(halfSize * 1.1, -halfSize * 0.5, 5, 12);
                    ctx.fillRect(-halfSize * 1.1 - 5, -halfSize * 0.5, 5, 12);
                } else if (currentShip.id === 'titan') {
                    ctx.fillRect(halfSize * 1.8, halfSize * 0.2, 8, 15);
                    ctx.fillRect(-halfSize * 1.8 - 8, halfSize * 0.2, 8, 15);
                } else if (currentShip.id === 'quantum' || currentShip.id === 'ultimate') {
                    ctx.fillRect(-2, -PLAYER_SIZE * 1.2, 4, 10);
                    ctx.fillRect(halfSize * 1.8, halfSize * 0.5, 6, 10);
                    ctx.fillRect(-halfSize * 1.8 - 6, halfSize * 0.5, 6, 10);
                }
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#161b22';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            balls.forEach(ball => {
                const x = ball.x, y = ball.y, r = ball.radius;
                ctx.shadowColor = METEOR_GLOW_COLOR;
                ctx.shadowBlur = 20;
                ctx.fillStyle = METEOR_BODY_COLOR;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                const damageRatio = ball.health / ball.maxHealth;
                if (damageRatio < 1.0) {
                    const red = 74 + (1 - damageRatio) * 150;
                    ctx.fillStyle = `rgb(${Math.floor(red)}, 74, 74)`;
                    ctx.beginPath();
                    ctx.arc(x, y, r * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#0d1117';
                    ctx.fillRect(x - r, y - r - 8, r * 2, 4);
                    ctx.fillStyle = damageRatio > 0.5 ? '#39ff14' : (damageRatio > 0.2 ? '#ffff00' : '#ff0000');
                    ctx.fillRect(x - r, y - r - 8, r * 2 * damageRatio, 4);
                }
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.beginPath();
                ctx.arc(x - r * 0.3, y - r * 0.3, r * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(x + r * 0.4, y + r * 0.1, r * 0.25, 0, Math.PI * 2);
                ctx.fill();
            });

            drawPlayer();
        }

        function gameLoop(currentTime) {
            if (!gameRunning) return;
            update(currentTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            playGameOverSound();
            disposeSynths();
            coins += sessionCoins;
            shopContainer.style.display = 'none';
            standardOverlay.style.display = 'flex';
            overlayTitle.textContent = 'GAME OVER';
            overlayTitle.classList.remove('text-cyan-400');
            overlayTitle.classList.add('text-red-500', 'animate-pulse');
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            const multiplier = currentShip ? currentShip.multiplier : 1;
            overlayMessage.textContent = `You survived for ${score.toFixed(2)} seconds and earned ${sessionCoins} new coins (${multiplier}x multiplier).`;
            totalCoinsMessage.textContent = `TOTAL BALANCE: ${coins} COINS`;
            actionButton.textContent = 'RESTART ARENA';
            overlay.style.display = 'flex';
            overlay.classList.add('game-over-visible');
            updateCoinDisplay();
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
            if (e.key === ' ' && gameRunning) shootProjectile();
        });
        document.addEventListener('keyup', (e) => { keys[e.key] = false; });
        canvas.addEventListener('click', () => { if (gameRunning) shootProjectile(); });

        let touchStart = { x: 0, y: 0 }, touchTimer = 0, isMoving = false;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStart.x = touch.clientX;
            touchStart.y = touch.clientY;
            touchTimer = Date.now();
            isMoving = false;
            const rect = canvas.getBoundingClientRect();
            const tx = touch.clientX - rect.left;
            const ty = touch.clientY - rect.top;
            const dx = tx - player.x;
            const dy = ty - player.y;
            let mx = 0, my = 0;
            if (Math.abs(dx) > 10) mx = dx > 0 ? 1 : -1;
            if (Math.abs(dy) > 10) my = dy > 0 ? 1 : -1;
            keys['w'] = my < 0; keys['s'] = my > 0;
            keys['a'] = mx < 0; keys['d'] = mx > 0;
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            isMoving = true;
            const touch = e.touches[0];
            const dx = touch.clientX - touchStart.x;
            const dy = touch.clientY - touchStart.y;
            const threshold = 15;
            keys['w'] = dy < -threshold; keys['s'] = dy > threshold;
            keys['a'] = dx < -threshold; keys['d'] = dx > threshold;
        }, { passive: false });
        canvas.addEventListener('touchend', () => {
            keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            const duration = Date.now() - touchTimer;
            if (duration < 150 && !isMoving && gameRunning) shootProjectile();
        });

        actionButton.addEventListener('click', startGame);
        shopButton.addEventListener('click', showShop);
        backButton.addEventListener('click', initStartScreen);
        window.addEventListener('resize', resizeCanvas);

        // Initialize the start screen
        initStartScreen();
    </script>
</body>
</html>
