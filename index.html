<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Dodge Arena (Combat)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Tone.js for sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Custom styles for the game elements */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@700&display=swap');

        body {
            background-color: #0d1117; /* Dark background */
            font-family: 'Chakra Petch', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.5), 0 0 50px rgba(0, 255, 255, 0.2);
            border: 4px solid #00ffff; /* Neon cyan border */
            border-radius: 12px;
            background-color: #161b22; /* Inner dark background */
        }

        canvas {
            display: block;
            touch-action: none; /* Prevent browser touch actions on canvas */
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Explicitly set to flex so JS can toggle between 'flex' and 'none' */
            display: flex; 
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            z-index: 10;
            pointer-events: none; /* Allows clicks to pass through by default */
        }

        .game-over-visible {
            pointer-events: auto !important; /* Enable interaction when visible */
        }

        .game-button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 0 15px #00ffff;
            background: linear-gradient(145deg, #00bfff, #00ffff);
            color: #0d1117;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 1.25rem;
            padding: 0.75rem 2rem;
            font-weight: 700;
        }
        .game-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px #00ffff, 0 0 50px #00ffff;
        }

        /* --- Shop specific styles --- */
        #shopContainer {
            background-color: #161b22;
            border: 2px solid #39ff14; /* Neon green accent */
            border-radius: 10px;
            max-width: 95%; /* Make it wider */
            width: 600px;
            max-height: 90%;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 1.5rem;
            padding: 2rem;
        }

        #shipList {
            /* Better grid layout for spacious cards */
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1.5rem;
            padding: 0.5rem;
            overflow-y: auto;
            max-height: 450px; /* slightly more height */
        }

        .ship-card {
            background-color: #1f2733;
            border: 1px solid #334d60;
            border-radius: 10px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s;
        }
        
        /* Apply custom border color based on ship glow */
        .ship-card[data-glow-color="#ff0000"] { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); } /* Viper */
        .ship-card[data-glow-color="#ee82ee"] { box-shadow: 0 0 10px rgba(238, 130, 238, 0.5); } /* Ghost */
        .ship-card[data-glow-color="#ffff00"] { box-shadow: 0 0 10px rgba(255, 255, 0, 0.5); } /* Titan */
        .ship-card[data-glow-color="#00bfff"] { box-shadow: 0 0 10px rgba(0, 191, 255, 0.5); } /* Quantum */
        .ship-card[data-glow-color="#39ff14"] { box-shadow: 0 0 15px rgba(57, 255, 20, 0.8); } /* Ultimate */

        .ship-card.equipped {
            border: 3px solid #39ff14;
            transform: scale(1.05);
            box-shadow: 0 0 20px #39ff14;
        }
        .ship-card:not(.equipped):hover {
            transform: translateY(-8px);
            border-color: #00ffff;
        }
    </style>
</head>
<body>
    <div id="game-container" class="w-full max-w-lg mx-auto aspect-square">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>

        <!-- Score Display (Time) -->
        <div id="scoreDisplay" class="absolute top-4 left-4 text-2xl font-bold text-cyan-400">
            TIME: 0.00s
        </div>
        
        <!-- Coin Display (New) -->
        <div id="coinDisplay" class="absolute top-4 right-4 text-2xl font-bold text-yellow-400">
            COINS: 0
        </div>

        <!-- Game Over / Start Overlay -->
        <div id="overlay">
            
            <!-- Standard Overlay Content (Start/Game Over) -->
            <div id="standardOverlay" class="flex flex-col justify-center items-center">
                <h1 id="overlayTitle" class="text-6xl mb-4 font-extrabold tracking-widest text-cyan-400"></h1>
                <p id="overlayMessage" class="text-4xl text-white mb-4 text-center"></p>
                <p id="totalCoinsMessage" class="text-3xl text-yellow-400 mb-8 text-center"></p>
                
                <button id="actionButton" class="game-button rounded-full">
                    <!-- Text updated by JS -->
                </button>
                <button id="shopButton" class="game-button rounded-full mt-4 bg-purple-600 shadow-md shadow-purple-900" style="box-shadow: 0 0 15px #ee82ee;">
                    VISIT THE SHOP
                </button>
                <p class="text-sm text-gray-400 mt-6">(Use WASD or Arrow Keys / Tap to move & shoot)</p>
            </div>


            <!-- Shop Container (Hidden by default) -->
            <div id="shopContainer" class="hidden w-full h-full p-4">
                <h2 class="text-4xl font-extrabold text-white mb-4 text-center pb-2 text-cyan-300">
                    SHIP MARKETPLACE
                </h2>

                <div id="shipList" class="grid" style="max-height: 450px;">
                    <!-- Ship cards will be dynamically inserted here -->
                </div>

                <div class="mt-4 flex flex-col sm:flex-row justify-between items-center border-t pt-4 border-cyan-500">
                    <p class="text-2xl text-yellow-400 font-bold mb-4 sm:mb-0">Balance: <span id="shopCoinBalance">0</span> COINS</p>
                    <button id="backButton" class="game-button rounded-full px-4 py-2" style="font-size: 1rem;">
                        BACK TO ARENA
                    </button>
                </div>
            </div>
            
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global environment variables (provided by the runtime)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- Firebase Initialization ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        // setLogLevel('debug'); // Uncomment for debugging Firestore

        let userId = null;
        let isAuthReady = false;
        
        // --- Game State Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const coinDisplay = document.getElementById('coinDisplay'); 
        const totalCoinsMessage = document.getElementById('totalCoinsMessage'); 

        // Overlay elements
        const overlay = document.getElementById('overlay');
        const standardOverlay = document.getElementById('standardOverlay');
        const shopContainer = document.getElementById('shopContainer');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMessage = document.getElementById('overlayMessage');
        const actionButton = document.getElementById('actionButton');
        const shopButton = document.getElementById('shopButton');
        const backButton = document.getElementById('backButton');
        const shipList = document.getElementById('shipList');
        const shopCoinBalance = document.getElementById('shopCoinBalance');

        // Game Constants
        const PLAYER_SIZE = 25;
        const METEOR_GLOW_COLOR = '#ff4500';
        const METEOR_BODY_COLOR = '#4a4a4a';
        const HIT_SOUND_COOLDOWN = 50; // ms: Limit how fast the hit sound can play

        // Ship Leaning Constants
        const ROTATION_SPEED = 0.15;
        const MAX_ROTATION = Math.PI / 8;

        // --- UPDATED SHIP DATA (With Damage) ---
        const SHIP_DATA = [
            // Default Ship (Always owned, 1x multiplier)
            { id: 'default', name: 'Standard Vanguard', multiplier: 1, price: 0, rarity: 'Standard', color: '#40e0d0', glow: '#00ffff', engineColor: '#ff6600', particleType: 0, damage: 1 },
            // Purchasable Ships 
            { id: 'viper', name: 'Crimson Viper', multiplier: 2, price: 30, rarity: 'Uncommon', color: '#8b0000', glow: '#ff0000', engineColor: '#ff4500', particleType: 1, damage: 2 },
            { id: 'ghost', name: 'Phantom Cloak', multiplier: 3, price: 100, rarity: 'Rare', color: '#9400d3', glow: '#ee82ee', engineColor: '#9400d3', particleType: 2, damage: 5 },
            { id: 'titan', name: 'Aether Titan', multiplier: 4, price: 250, rarity: 'Epic', color: '#daa520', glow: '#ffff00', engineColor: '#daa520', particleType: 1, damage: 10 },
            { id: 'quantum', name: 'Quantum Core', multiplier: 5, price: 500, rarity: 'Legendary', color: '#ffffff', glow: '#00bfff', engineColor: '#00ffff', particleType: 3, damage: 20 },
            { id: 'ultimate', name: 'Nebula Sovereign', multiplier: 6, price: 1000, rarity: 'Mythic', color: '#39ff14', glow: '#39ff14', engineColor: '#39ff14', particleType: 2, damage: 40 }
        ];

        // Game State
        let gameRunning = false;
        let player = { x: 0, y: 0, dx: 0, dy: 0, speed: 5, rotation: 0, particles: [] }; 
        let balls = [];
        let projectiles = []; // NEW: Array for player projectiles
        let score = 0;
        let lastTime = 0;
        let spawnTimer = 0;
        let ballSpeedFactor = 1.0;
        let spawnInterval = 1000; // milliseconds
        
        let coins = 0; // Persistent coin total
        let sessionCoins = 0; // Coins earned in the current session
        let lastCoinUpdateTime = 0; // To track time for coin earning
        let equippedShipId = 'default'; // New state
        let ownedShipIds = ['default']; // New state
        let lastHitSoundTime = 0; // NEW: Track last hit sound play time

        // Key/Input state
        let keys = {};
        
        // --- Tone.js Sound Setup ---
        
        const bpm = 128;
        let isToneInitialized = false;

        // Synths for Music
        const padSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.5, decay: 0.1, sustain: 0.9, release: 0.8 },
            volume: -15
        }).toDestination();
        const bassSynth = new Tone.MonoSynth({
            oscillator: { type: "square" },
            envelope: { attack: 0.005, decay: 0.2, sustain: 0.01, release: 0.1 },
            filterEnvelope: { attack: 0.06, decay: 0.02, sustain: 0.5, release: 2, basePath: 200, octaves: 4 },
            volume: -8
        }).toDestination();
        const kick = new Tone.MembraneSynth({
            volume: -3, pitchDecay: 0.05, octaves: 5, envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.8 }
        }).toDestination();
        const snare = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 },
            volume: -10
        }).toDestination();

        // Game Over/Hit Sound (Noise)
        const noiseSynth = new Tone.NoiseSynth({
            noise: { type: 'white' },
            envelope: { attack: 0.001, decay: 0.15, sustain: 0.01, release: 0.15 }
        }).toDestination();

        // NEW: Laser Sound
        const laserSynth = new Tone.Synth({
            oscillator: { type: "square" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 },
            volume: -15 // Lower volume slightly
        }).toDestination();

        // NEW: Meteor Hit Sound
        const hitSynth = new Tone.MembraneSynth({
            volume: -18, pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.05 }
        }).toDestination();

        // Music Loop State
        const chords = [
            ["C3", "E3", "G3"], // C Major
            ["G3", "B3", "D4"], // G Major
            ["Am3", "C4", "E4"],// A minor
            ["F3", "A3", "C4"]  // F Major
        ];
        const bassline = ["C2", "G2", "A2", "F2"]; // Roots

        let chordLoop = null;
        let bassLoop = null;
        let drumLoop = null;

        function initializeTone() {
            if (!isToneInitialized) { 
                Tone.start(); 
                Tone.Transport.bpm.value = bpm;
                isToneInitialized = true; 
            }
        }
        
        function startMusic() {
            stopMusic(); // Clear any existing loops
            
            // Chord Pad Loop (4/4 timing, every 1 measure)
            chordLoop = new Tone.Loop(time => {
                const index = chordLoop.index % chords.length;
                padSynth.triggerAttackRelease(chords[index], "1m", time);
            }, "1m").start(0);

            // Bass Loop (4/4 timing, 8th notes, playing each root for two 8th notes)
            bassLoop = new Tone.Sequence((time, note) => {
                bassSynth.triggerAttackRelease(note, "8n", time);
            }, bassline.flatMap(root => [root, root, root, root, root, root, root, root]), "8n").start(0);
            bassLoop.playbackRate = 0.5;

            // Drum Loop (4/4 timing)
            drumLoop = new Tone.Sequence((time, step) => {
                if (step % 4 === 0) { // Kick on 1, 2, 3, 4
                    kick.triggerAttackRelease("C1", "8n", time);
                }
                if (step === 4 || step === 12) { // Snare on 2 and 4
                    snare.triggerAttackRelease("16n", time, 0.7);
                }
            }, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "16n").start(0);

            Tone.Transport.start();
        }

        function stopMusic() {
            if (chordLoop) { chordLoop.stop(); chordLoop.dispose(); chordLoop = null; }
            if (bassLoop) { bassLoop.stop(); bassLoop.dispose(); bassLoop = null; }
            if (drumLoop) { drumLoop.stop(); drumLoop.dispose(); drumLoop = null; }
            Tone.Transport.stop();
        }
        
        function playStartSound() { 
            padSynth.triggerAttackRelease(["C4", "E4"], "8n");
            padSynth.triggerAttackRelease(["G4", "C5"], "8n", "+0.15"); 
        }
        function playGameOverSound() { 
            noiseSynth.triggerAttackRelease("2n", Tone.now(), 0.5); 
            stopMusic(); 
        }
        
        // NEW: Laser and Hit Sounds
        function playLaserSound() {
            laserSynth.triggerAttackRelease("C5", "16n");
        }
        function playHitSound() {
            const currentTime = performance.now();
            // Implement cooldown check to prevent Tone.js timing errors
            if (currentTime - lastHitSoundTime < HIT_SOUND_COOLDOWN) {
                return;
            }
            hitSynth.triggerAttackRelease("C3", "32n");
            lastHitSoundTime = currentTime; // Update the timestamp
        }
        // --- END Tone.js Music/Sound Setup ---


        // --- Firebase Functions ---

        // Returns the document reference for the user's private game data
        function getCoinDocRef() {
            if (!userId) {
                console.error("Attempted to access Firestore before user ID is set.");
                return null;
            }
            // Private data path: /artifacts/{appId}/users/{userId}/gameData/coinData
            return doc(db, 'artifacts', appId, 'users', userId, 'gameData', 'coinData');
        }

        async function loadCoins() {
            if (!isAuthReady || !userId) {
                console.warn("Authentication not ready. Cannot load coins.");
                return;
            }
            try {
                const docRef = getCoinDocRef();
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    coins = data.totalCoins || 0;
                    equippedShipId = data.equippedShipId || 'default';
                    ownedShipIds = data.ownedShipIds || ['default'];
                    
                    // Sanity check: ensure the equipped ship is actually owned
                    if (!ownedShipIds.includes(equippedShipId)) {
                        equippedShipId = 'default';
                        ownedShipIds = ['default'];
                    }
                } else {
                    // Initialize document if it doesn't exist
                    await setDoc(docRef, { totalCoins: 0, equippedShipId: 'default', ownedShipIds: ['default'] });
                    coins = 0;
                    equippedShipId = 'default';
                    ownedShipIds = ['default'];
                    console.log("Coin data initialized.");
                }
            } catch (error) {
                console.error("Error loading coins:", error);
            }
            updateCoinDisplay();
        }

        async function saveCoins() {
            if (!isAuthReady || !userId) {
                console.error("Authentication not ready. Cannot save coins.");
                return;
            }
            try {
                const docRef = getCoinDocRef();
                await setDoc(docRef, { 
                    totalCoins: coins,
                    equippedShipId: equippedShipId,
                    ownedShipIds: ownedShipIds
                }, { merge: true });
                console.log("Game state saved successfully. Coins:", coins, "Ship:", equippedShipId);
            } catch (error) {
                console.error("Error saving game state:", error);
            }
        }

        function updateCoinDisplay() {
             coinDisplay.textContent = `COINS: ${coins + sessionCoins}`;
             if (document.getElementById('shopCoinBalance')) {
                 document.getElementById('shopCoinBalance').textContent = coins;
             }
        }

        // --- Shop Logic ---

        // FIX: Expose shop functions globally so they can be called from dynamically generated HTML
        window.attemptPurchase = attemptPurchase;
        window.equipShip = equipShip;

        function showShop() {
            if (!isAuthReady) return;
            standardOverlay.style.display = 'none';
            shopContainer.style.display = 'grid';
            overlay.style.display = 'flex';
            overlay.classList.add('game-over-visible');
            renderShop();
            updateCoinDisplay();
        }

        function renderShop() {
            shipList.innerHTML = ''; // Clear previous cards

            SHIP_DATA.forEach(ship => {
                const isOwned = ownedShipIds.includes(ship.id);
                const isEquipped = equippedShipId === ship.id;

                let buttonText = 'EQUIP';
                let buttonClasses = 'px-3 py-1 text-sm rounded-full font-bold transition-all';
                let action = `equipShip('${ship.id}')`;
                
                if (!isOwned) {
                    buttonText = `BUY - ${ship.price} COINS`;
                    buttonClasses += ' bg-yellow-500 hover:bg-yellow-400 text-gray-900 shadow-lg shadow-yellow-700/50';
                    action = `attemptPurchase('${ship.id}', ${ship.price})`;
                } else if (isEquipped) {
                    buttonText = 'EQUIPPED';
                    buttonClasses += ' bg-green-500 opacity-80 cursor-default text-gray-900 shadow-lg shadow-green-700/50';
                    action = '';
                } else {
                    buttonClasses += ' bg-cyan-500 hover:bg-cyan-400 text-gray-900 shadow-lg shadow-cyan-700/50';
                }

                // Determine rarity color
                let rarityColor = 'text-gray-400';
                if (ship.rarity === 'Uncommon') rarityColor = 'text-green-400';
                else if (ship.rarity === 'Rare') rarityColor = 'text-blue-400';
                else if (ship.rarity === 'Epic') rarityColor = 'text-purple-400';
                else if (ship.rarity === 'Legendary') rarityColor = 'text-yellow-400';
                else if (ship.rarity === 'Mythic') rarityColor = 'text-pink-400';


                const card = document.createElement('div');
                card.className = `ship-card ${isEquipped ? 'equipped' : ''}`;
                // Add custom attribute for glow CSS styling
                card.setAttribute('data-glow-color', ship.glow); 
                card.innerHTML = `
                    <h3 class="text-2xl font-bold ${rarityColor} mb-1">${ship.name}</h3>
                    <p class="text-sm ${rarityColor} italic mb-2">(${ship.rarity})</p>

                    <!-- Ship Preview Circle -->
                    <div class="w-20 h-20 rounded-full flex items-center justify-center mb-4 border-2 border-white/20" 
                         style="background-color: ${ship.color}; box-shadow: 0 0 20px ${ship.glow}, inset 0 0 8px white;">
                        <!-- Simple icon to represent the ship -->
                        <svg class="w-10 h-10" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: ${ship.engineColor};">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                        </svg>
                    </div>

                    <p class="text-white text-lg font-mono mb-1">Multiplier: <span class="text-cyan-400">${ship.multiplier}x</span></p>
                    <p class="text-white text-lg font-mono mb-4">Damage: <span class="text-red-400">${ship.damage}</span></p>

                    <button onclick="${action}" class="${buttonClasses}" ${isEquipped ? 'disabled' : ''}>
                        ${buttonText}
                    </button>
                    <p id="msg-${ship.id}" class="text-xs text-red-400 mt-2 h-4"></p>
                `;
                shipList.appendChild(card);
            });
        }

        function attemptPurchase(shipId, price) {
            if (coins >= price) {
                coins -= price;
                ownedShipIds.push(shipId);
                equipShip(shipId); // Automatically equip after purchase
                saveCoins();
                
                // Show success message
                const msgEl = document.getElementById(`msg-${shipId}`);
                if (msgEl) {
                    msgEl.textContent = 'Purchased & Equipped!';
                    msgEl.classList.remove('text-red-400');
                    msgEl.classList.add('text-green-400');
                    setTimeout(() => msgEl.textContent = '', 2000);
                }

            } else {
                // Show error message
                const msgEl = document.getElementById(`msg-${shipId}`);
                if (msgEl) {
                    msgEl.textContent = 'Not enough coins!';
                    msgEl.classList.add('text-red-400');
                    msgEl.classList.remove('text-green-400');
                    setTimeout(() => msgEl.textContent = '', 2000);
                }
            }
            renderShop();
            updateCoinDisplay();
        }

        function equipShip(shipId) {
            if (ownedShipIds.includes(shipId)) {
                equippedShipId = shipId;
                saveCoins();
                renderShop();
                // Show success message
                const msgEl = document.getElementById(`msg-${shipId}`);
                if (msgEl) {
                    msgEl.textContent = 'Equipped!';
                    msgEl.classList.remove('text-red-400');
                    msgEl.classList.add('text-green-400');
                    setTimeout(() => msgEl.textContent = '', 2000);
                }
            }
        }
        
        // --- Auth Setup (Wait for Authentication before loading data) ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
            } else {
                // Sign in anonymously if no token is available
                if (initialAuthToken) {
                    try {
                        const credential = await signInWithCustomToken(auth, initialAuthToken);
                        userId = credential.user.uid;
                    } catch (error) {
                        console.error("Error signing in with custom token, signing in anonymously:", error);
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                } else {
                    await signInAnonymously(auth);
                    userId = auth.currentUser.uid;
                }
            }
            isAuthReady = true;
            console.log("Auth is ready. User ID:", userId);
            
            // Once authenticated, proceed to initial screen setup and load data
            initStartScreen();
        });

        // --- Game Logic Functions ---

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const size = Math.min(container.offsetWidth, container.offsetHeight);
            canvas.width = size;
            canvas.height = size;
        }

        function startGame() {
            if (!isAuthReady) {
                // Using console.warn instead of alert()
                console.warn("Please wait for authentication to load."); 
                return;
            }
            
            initializeTone();
            playStartSound();
            startMusic();
            
            // Setup initial game state
            resizeCanvas();
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.dx = 0;
            player.dy = 0;
            player.rotation = 0;
            player.particles = []; // Reset particles

            balls = [];
            projectiles = []; // NEW: Reset projectiles
            score = 0;
            sessionCoins = 0; // Reset session coins
            lastTime = performance.now();
            lastCoinUpdateTime = lastTime; // Start coin timer
            lastHitSoundTime = 0; // Reset sound throttle timer
            spawnTimer = spawnInterval;
            ballSpeedFactor = 1.0;
            keys = {};

            overlay.classList.remove('game-over-visible');
            overlay.style.display = 'none'; 
            gameRunning = true;
            
            updateCoinDisplay();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function initStartScreen() {
            // Draw initial clean state immediately
            resizeCanvas();
            draw(); 

            // Load coins once auth is ready
            if (isAuthReady) {
                loadCoins();
            } else {
                // If not ready, use a default state until onAuthStateChanged finishes
                coins = 0;
                updateCoinDisplay();
            }

            // Show standard overlay content
            shopContainer.style.display = 'none';
            standardOverlay.style.display = 'flex';

            overlayTitle.textContent = 'BALL DODGE ARENA';
            overlayTitle.classList.remove('text-red-500', 'animate-pulse');
            overlayTitle.classList.add('text-cyan-400');
            
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            const multiplier = currentShip ? currentShip.multiplier : 1;
            const damage = currentShip ? currentShip.damage : 1;


            overlayMessage.textContent = `Equipped: ${currentShip.name} (${multiplier}x Multiplier, ${damage} Damage).`;
            totalCoinsMessage.textContent = ''; // Clear coin message on start screen
            actionButton.textContent = 'START ARENA';
            
            overlay.style.display = 'flex';
            overlay.classList.add('game-over-visible');
        }

        function spawnBall() {
            const minBallSize = 15;
            const maxBallSize = 25;
            const size = Math.floor(Math.random() * (maxBallSize - minBallSize + 1)) + minBallSize;
            const radius = size / 2;

            const health = Math.max(1, Math.floor(radius * 1.5)); // Health based on size
            
            const newBall = {
                x: Math.random() * (canvas.width - size * 2) + size, 
                y: -size, 
                radius: radius,
                speed: (3 + Math.random() * 3) * ballSpeedFactor, 
                health: health,      // NEW
                maxHealth: health,   // NEW
            };
            balls.push(newBall);
        }

        function shootProjectile() {
            if (!gameRunning) return;
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            if (!currentShip) return;
            
            playLaserSound();

            // Simple upward shot from the player's front
            projectiles.push({
                x: player.x,
                y: player.y - PLAYER_SIZE,
                radius: 3,
                speed: 15, // Fast projectile
                damage: currentShip.damage,
                color: currentShip.glow,
                vx: 0,
                vy: -1,
            });
        }

        function updateParticles(deltaTime) {
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            if (!currentShip || currentShip.particleType === 0) {
                player.particles = [];
                return;
            }

            // Add new particles
            if (Math.random() < 0.8) {
                const angle = player.rotation;
                const baseLength = PLAYER_SIZE * 0.7;
                const offset = {
                    x: baseLength * Math.sin(angle),
                    y: baseLength * Math.cos(angle)
                };
                
                player.particles.push({
                    x: player.x - offset.x + (Math.random() - 0.5) * 8,
                    y: player.y + offset.y + (Math.random() - 0.5) * 8,
                    // vx and vy control the direction of the exhaust
                    vx: -(Math.sin(angle) * 0.5 + (Math.random() - 0.5) * 0.5),
                    vy: (Math.cos(angle) * 0.5 + (Math.random() * 2)),
                    life: 100, // lifetime in frames
                    size: currentShip.particleType === 3 ? 2.5 : 1.5, // Larger particles for Quantum Core
                    color: currentShip.engineColor
                });
            }

            // Update existing particles
            for (let i = player.particles.length - 1; i >= 0; i--) {
                const p = player.particles[i];
                p.x += p.vx * deltaTime / 16.67;
                p.y += p.vy * deltaTime / 16.67;
                p.life -= 1;
                p.vy *= 0.98; // Slow down vertically

                if (p.life <= 0) {
                    player.particles.splice(i, 1);
                }
            }
        }


        function update(currentTime) {
            if (!gameRunning) return;

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            const deltaSeconds = deltaTime / 1000;

            // 1. Update Score
            score += deltaSeconds;
            scoreDisplay.textContent = `TIME: ${score.toFixed(2)}s`;

            // 2. Coin Earning (with multiplier)
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            const multiplier = currentShip ? currentShip.multiplier : 1;

            if (currentTime - lastCoinUpdateTime >= 1000) {
                const secondsPassed = Math.floor((currentTime - lastCoinUpdateTime) / 1000);
                sessionCoins += multiplier * secondsPassed;
                lastCoinUpdateTime += secondsPassed * 1000;
                updateCoinDisplay();
            }

            // 3. Player Movement 
            let moveX = player.dx;
            let moveY = player.dy;

            if (keys['w'] || keys['W'] || keys['ArrowUp']) moveY = -1;
            else if (keys['s'] || keys['S'] || keys['ArrowDown']) moveY = 1;
            else moveY = 0;

            if (keys['a'] || keys['A'] || keys['ArrowLeft']) moveX = -1;
            else if (keys['d'] || keys['D'] || keys['ArrowRight']) moveX = 1;
            else moveX = 0;
            
            if (moveX !== 0 && moveY !== 0) {
                const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
                moveX /= magnitude;
                moveY /= magnitude;
            }

            player.x += moveX * player.speed;
            player.y += moveY * player.speed;

            let targetRotation = 0;
            if (moveX < 0) { targetRotation = -MAX_ROTATION; } 
            else if (moveX > 0) { targetRotation = MAX_ROTATION; }
            player.rotation += (targetRotation - player.rotation) * ROTATION_SPEED; 

            const halfSize = PLAYER_SIZE / 2;
            player.x = Math.max(halfSize, Math.min(canvas.width - halfSize, player.x));
            player.y = Math.max(halfSize, Math.min(canvas.height - halfSize, player.y));
            
            // Update particles based on movement
            updateParticles(deltaTime);


            // 4. Ball Spawning and Difficulty Scaling
            spawnTimer -= deltaTime;
            if (spawnTimer <= 0) {
                spawnBall();
                ballSpeedFactor = 1.0 + Math.min(score / 50, 4.0);
                spawnInterval = Math.max(1000 - score * 10, 50);
                spawnTimer = spawnInterval;
            }

            // 5. Ball Movement and Cleanup & Collision (Player to Ball)
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                ball.y += ball.speed * (deltaTime / 16.67);
                
                if (ball.y - ball.radius > canvas.height) {
                    balls.splice(i, 1);
                }
                
                if (checkCollision(player, ball)) {
                    gameOver();
                    return;
                }
            }

            // 6. Projectile Movement and Collision (Projectile to Ball)
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.y += p.vy * p.speed * (deltaTime / 16.67);

                // Check if projectile is off-screen
                if (p.y + p.radius < 0) {
                    projectiles.splice(i, 1);
                    continue;
                }

                let hit = false;
                for (let j = balls.length - 1; j >= 0; j--) {
                    const ball = balls[j];
                    const dx = p.x - ball.x;
                    const dy = p.y - ball.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < (p.radius + ball.radius)) {
                        // HIT!
                        hit = true;
                        ball.health -= p.damage;
                        playHitSound(); // Now throttled
                        
                        if (ball.health <= 0) {
                            // Destroyed! Grant coins.
                            const coinReward = Math.ceil(ball.maxHealth / 2); // Reward based on original health
                            sessionCoins += coinReward;
                            updateCoinDisplay();
                            balls.splice(j, 1);
                        }
                        break; // Projectile can only hit one ball
                    }
                }
                
                if (hit) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function checkCollision(p, b) {
            const dx = p.x - b.x;
            const dy = p.y - b.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (b.radius + PLAYER_SIZE / 2); 
        }

        // --- drawPlayer FUNCTION ---
        function drawPlayer() {
            // Find the currently equipped ship's data
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId) || SHIP_DATA[0];

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.rotation); 

            const halfSize = PLAYER_SIZE / 2;
            
            // Draw particles first so they appear behind the ship (Engine Trails)
            player.particles.forEach(p => {
                ctx.globalAlpha = p.life / 100;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x - player.x, p.y - player.y, p.size * (p.life/100), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });

            // 1. Draw Engine Exhaust Glow
            ctx.shadowColor = currentShip.engineColor;
            ctx.shadowBlur = 10;
            ctx.fillStyle = currentShip.engineColor; 
            ctx.fillRect(-halfSize * 0.6, halfSize, halfSize * 1.2, PLAYER_SIZE * 0.5); 
            
            // 2. Draw Main Ship Body 
            ctx.shadowColor = currentShip.glow; // Use the equipped ship's glow color
            ctx.shadowBlur = 15;
            ctx.fillStyle = currentShip.color; // Use the equipped ship's main color
            
            ctx.beginPath();
            
            // --- Custom Ship Shapes (New shapes start from 'ghost') ---
            if (currentShip.id === 'default' || currentShip.id === 'viper') {
                // Original Triangle Shape
                ctx.moveTo(0, -PLAYER_SIZE);
                ctx.lineTo(halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 1.5, halfSize);
                
            } else if (currentShip.id === 'ghost') {
                // New Shape: Hexagonal/Stealthier
                ctx.moveTo(0, -PLAYER_SIZE);
                ctx.lineTo(halfSize * 1.5, halfSize * 0.5);
                ctx.lineTo(halfSize * 0.8, halfSize);
                ctx.lineTo(-halfSize * 0.8, halfSize);
                ctx.lineTo(-halfSize * 1.5, halfSize * 0.5);
                
            } else if (currentShip.id === 'titan') {
                // New Shape: Wide and sturdy (Rectangle with swept wings)
                ctx.moveTo(0, -PLAYER_SIZE);
                ctx.lineTo(halfSize * 2, halfSize * 0.8);
                ctx.lineTo(halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 2, halfSize * 0.8);
                
            } else if (currentShip.id === 'quantum' || currentShip.id === 'ultimate') {
                // New Shape: Split/Advanced Fighter
                ctx.moveTo(0, -PLAYER_SIZE * 1.2);
                ctx.lineTo(halfSize * 0.5, -halfSize * 0.5);
                ctx.lineTo(halfSize * 2, halfSize * 0.8);
                ctx.lineTo(halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 1.5, halfSize);
                ctx.lineTo(-halfSize * 2, halfSize * 0.8);
                ctx.lineTo(-halfSize * 0.5, -halfSize * 0.5);
            }
            // --- End Custom Ship Shapes ---

            ctx.closePath();
            ctx.fill();

            // 3. Cockpit/Detail (Do this before guns to avoid shadow issues)
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#0d1117'; // Always black for cockpit
            ctx.beginPath();
            ctx.arc(0, -PLAYER_SIZE * 0.4, PLAYER_SIZE * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // 4. Draw Guns (Starting from 'ghost' ship)
            if (currentShip.id === 'ghost' || currentShip.id === 'titan' || currentShip.id === 'quantum' || currentShip.id === 'ultimate') {
                 ctx.fillStyle = currentShip.engineColor;
                 ctx.shadowColor = currentShip.engineColor;
                 ctx.shadowBlur = 5;

                 if (currentShip.id === 'ghost') {
                    // Subtle guns near the front
                    ctx.fillRect(halfSize * 1.1, -halfSize * 0.5, 5, 12);
                    ctx.fillRect(-halfSize * 1.1 - 5, -halfSize * 0.5, 5, 12);
                 } else if (currentShip.id === 'titan') {
                    // Large cannons at the sides
                    ctx.fillRect(halfSize * 1.8, halfSize * 0.2, 8, 15);
                    ctx.fillRect(-halfSize * 1.8 - 8, halfSize * 0.2, 8, 15);
                 } else if (currentShip.id === 'quantum' || currentShip.id === 'ultimate') {
                    // Multiple, bright cannons
                    // Center Cannons (on the nose)
                    ctx.fillRect(-2, -PLAYER_SIZE * 1.2, 4, 10);
                    // Wing Cannons
                    ctx.fillRect(halfSize * 1.8, halfSize * 0.5, 6, 10);
                    ctx.fillRect(-halfSize * 1.8 - 6, halfSize * 0.5, 6, 10);
                 }
                 ctx.shadowBlur = 0;
            }

            ctx.restore();
        }
        // --- END drawPlayer FUNCTION ---

        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#161b22'; // Arena background
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Projectiles (NEW)
            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Reset shadows for next elements
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // 2. Draw Meteors 
            balls.forEach(ball => {
                const x = ball.x;
                const y = ball.y;
                const r = ball.radius;

                // 1. Draw the Heat/Atmospheric Glow (Shadow)
                ctx.shadowColor = METEOR_GLOW_COLOR;
                ctx.shadowBlur = 20;

                // 2. Draw the main rock body (Darker circle)
                ctx.fillStyle = METEOR_BODY_COLOR;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();

                // 3. Draw Inner Light/Cracks (No shadow needed for this detail)
                ctx.shadowBlur = 0; 
                
                // Add visual damage based on health (NEW)
                const damageRatio = ball.health / ball.maxHealth;
                if (damageRatio < 1.0) {
                    // Damage color: Redder as health drops
                    const red = 74 + (1 - damageRatio) * 150; 
                    const damageColor = `rgb(${Math.floor(red)}, 74, 74)`;
                    
                    // Draw a damaged body (slightly smaller circle based on damage)
                    ctx.fillStyle = damageColor;
                    ctx.beginPath();
                    ctx.arc(x, y, r * 0.9, 0, Math.PI * 2); 
                    ctx.fill();
                    
                    // Draw a simple health bar
                    ctx.fillStyle = '#0d1117';
                    ctx.fillRect(x - r, y - r - 8, r * 2, 4);
                    
                    // Health bar color changes from green -> yellow -> red
                    ctx.fillStyle = damageRatio > 0.5 ? '#39ff14' : (damageRatio > 0.2 ? '#ffff00' : '#ff0000');
                    ctx.fillRect(x - r, y - r - 8, r * 2 * damageRatio, 4);
                }


                // Simple light spot/glint
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)'; 
                ctx.beginPath();
                ctx.arc(x - r * 0.3, y - r * 0.3, r * 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Simulate a small crater/dark spot
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; 
                ctx.beginPath();
                ctx.arc(x + r * 0.4, y + r * 0.1, r * 0.25, 0, Math.PI * 2);
                ctx.fill();
            });

            // Reset shadows for player
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // 3. Draw Player
            drawPlayer();
        }

        function gameLoop() {
            if (!gameRunning) return;

            const currentTime = performance.now();
            update(currentTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameRunning = false;
            playGameOverSound();

            // 1. Update persistent coin total and save
            coins += sessionCoins;
            saveCoins();
            
            // 2. Update Game Over Screen
            shopContainer.style.display = 'none';
            standardOverlay.style.display = 'flex';

            overlayTitle.textContent = 'GAME OVER';
            overlayTitle.classList.remove('text-cyan-400');
            overlayTitle.classList.add('text-red-500', 'animate-pulse');
            
            const currentShip = SHIP_DATA.find(s => s.id === equippedShipId);
            const multiplier = currentShip ? currentShip.multiplier : 1;
            
            overlayMessage.textContent = `You survived for ${score.toFixed(2)} seconds and earned ${sessionCoins} new coins (${multiplier}x multiplier).`; 
            totalCoinsMessage.textContent = `TOTAL BALANCE: ${coins} COINS`;

            actionButton.textContent = 'RESTART ARENA';
            
            overlay.style.display = 'flex';
            overlay.classList.add('game-over-visible');
            
            updateCoinDisplay(); // Ensure the corner coin display reflects the new total
        }

        // --- Event Listeners and Setup ---

        // 1. Keyboard Input for Desktop
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            // Spacebar to shoot (NEW)
            if (e.key === ' ' && gameRunning) {
                shootProjectile();
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // 2. Mouse/Click Input (NEW: Click to shoot)
        canvas.addEventListener('click', (e) => {
            if (gameRunning) {
                shootProjectile();
            }
        });

        // 3. Touch Input for Mobile
        let touchStart = { x: 0, y: 0 };
        let touchTimer = 0;
        let isMoving = false;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStart.x = touch.clientX;
            touchStart.y = touch.clientY;
            touchTimer = Date.now();
            isMoving = false;
            
            // Set initial movement state based on touch direction relative to player, for immediate response
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            const dx = touchX - player.x;
            const dy = touchY - player.y;

            let moveX = 0, moveY = 0;
            if (Math.abs(dx) > 10) moveX = dx > 0 ? 1 : -1;
            if (Math.abs(dy) > 10) moveY = dy > 0 ? 1 : -1;

            keys['w'] = moveY < 0; keys['s'] = moveY > 0;
            keys['a'] = moveX < 0; keys['d'] = moveX > 0;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            isMoving = true;
            const touch = e.touches[0];
            const dx = touch.clientX - touchStart.x;
            const dy = touch.clientY - touchStart.y;
            
            const threshold = 15;

            keys['w'] = dy < -threshold; keys['s'] = dy > threshold;
            keys['a'] = dx < -threshold; keys['d'] = dx > threshold;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;

            // Check for a quick tap (not moving much, quick release) to register a shot
            const touchDuration = Date.now() - touchTimer;
            if (touchDuration < 150 && !isMoving && gameRunning) {
                 shootProjectile();
            }
        });


        // 4. Action Button (Start/Restart)
        actionButton.addEventListener('click', startGame);
        shopButton.addEventListener('click', showShop);
        backButton.addEventListener('click', initStartScreen);

        // 5. Initial setup and responsiveness
        window.addEventListener('resize', resizeCanvas);
        
        // initStartScreen is triggered by onAuthStateChanged.
    </script>
</body>
</html>